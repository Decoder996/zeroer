# DeepMatcher 数据集转换为 ZeroER 格式指南

## 概述

你可以将 `datasets_raw` 中的 deepmatcher 格式数据集转换为 zeroER 格式，然后测试 F1 分数。

## 可用数据集

在 `datasets_raw/Structured/` 中有以下数据集：
- Amazon-Google
- Amazon-GoogleProducts (已有 blocking 函数)
- Beer (已有 blocking 函数)
- DBLP-ACM (已有 blocking 函数)
- DBLP-GoogleScholar (已有 blocking 函数)
- Fodors-Zagats (已有 blocking 函数)
- iTunes-Amazon (已有 blocking 函数)
- Walmart-Amazon (已有 blocking 函数)

## 转换步骤

### 步骤 1: 转换数据集

使用通用转换脚本：

```bash
# 基本用法
python convert_any_dataset.py <source_dir> <target_name>

# 示例：转换 DBLP-ACM
python convert_any_dataset.py datasets_raw/Structured/DBLP-ACM dblp_acm

# 示例：转换 iTunes-Amazon
python convert_any_dataset.py datasets_raw/Structured/iTunes-Amazon itunes_amazon
```

### 步骤 2: 添加 Blocking 函数

检查 `blocking_functions.py`，看看是否已有对应的 blocking 函数：

```python
# 如果已有，直接添加映射
blocking_functions_mapping["your_dataset"] = block_existing_function

# 如果没有，需要编写新的 blocking 函数
def block_your_dataset(A, B):
    ob = em.OverlapBlocker()
    # 根据数据集特点调整参数
    C = ob.block_tables(A, B, 'key_column', 'key_column', 
                        word_level=True, 
                        overlap_size=2,  # 根据数据集调整
                        show_progress=True)
    return C
```

### 步骤 3: 运行 ZeroER

```bash
python zeroer.py <dataset_name>
```

## 已配置的数据集

以下数据集已经有 blocking 函数，可以直接转换和使用：

1. **amazon_googleproducts** - 已有 `block_amazon_googleproducts`
2. **beer** - 已有 `block_beer`
3. **dblp_acm** - 已有 `block_dblp_acm`
4. **dblp_scholar** - 已有 `block_dblp_scholar`
5. **fodors_zagats** - 已有 `block_fodors_zagats`
6. **walmart_amazon** - 已有 `block_walmart_amazon`
7. **abt_buy** - 已有 `block_abt_buy`
8. **iTunes-Amazon** - 需要检查是否有对应的 blocking 函数

## 快速转换示例

### 示例 1: 转换 DBLP-ACM（已有 blocking 函数）

```bash
# 1. 转换数据集
python convert_any_dataset.py datasets_raw/Structured/DBLP-ACM dblp_acm

# 2. 检查 blocking 函数是否已配置
# (dblp_acm 已有 block_dblp_acm 函数)

# 3. 运行 zeroER
python zeroer.py dblp_acm
```

### 示例 2: 转换新数据集（需要添加 blocking 函数）

```bash
# 1. 转换数据集
python convert_any_dataset.py datasets_raw/Structured/Amazon-Google amazon_google

# 2. 查看数据，确定 blocking 策略
head datasets/amazon_google/tableA.csv
head datasets/amazon_google/tableB.csv

# 3. 在 blocking_functions.py 中添加 blocking 函数
# 4. 添加映射：blocking_functions_mapping["amazon_google"] = block_amazon_google

# 5. 运行 zeroER
python zeroer.py amazon_google
```

## 注意事项

### 1. 字符串格式问题

如果转换后的数据集有字符串格式问题（类似 fodors_zagats_test），可以使用修复脚本：

```bash
# 检查数据格式
python3 -c "import pandas as pd; df = pd.read_csv('datasets/<dataset>/tableA.csv'); print(df['name'].iloc[0] if 'name' in df.columns else 'No name column')"

# 如果有格式问题，修改 fix_fodors_zagats_test_simple.py 并应用到新数据集
```

### 2. Blocking 参数调整

根据数据集大小调整 blocking 参数：
- **小数据集** (< 10K 行): `overlap_size=1` 或 `2`
- **中等数据集** (10K-100K 行): `overlap_size=2` 或 `3`
- **大数据集** (> 100K 行): `overlap_size=3` 或 `4`

### 3. 特征提取时间

- 小数据集 (< 5K 候选对): 几分钟
- 中等数据集 (5K-50K 候选对): 10-30 分钟
- 大数据集 (> 50K 候选对): 可能需要几小时

建议使用 `--n_jobs 2` 或 `--n_jobs 4` 控制 CPU 占用。

## 批量转换脚本

如果需要批量转换多个数据集，可以创建一个脚本：

```bash
#!/bin/bash
# convert_all.sh

datasets=(
    "DBLP-ACM:dblp_acm"
    "DBLP-GoogleScholar:dblp_scholar"
    "iTunes-Amazon:itunes_amazon"
    "Walmart-Amazon:walmart_amazon"
)

for dataset in "${datasets[@]}"; do
    IFS=':' read -r source target <<< "$dataset"
    echo "Converting $source to $target..."
    python convert_any_dataset.py "datasets_raw/Structured/$source" "$target"
done
```

## 验证转换结果

转换后检查：

```bash
# 检查文件是否存在
ls -lh datasets/<dataset_name>/

# 检查数据行数
wc -l datasets/<dataset_name>/*.csv

# 检查 matches 文件
head datasets/<dataset_name>/matches.csv
```

## 测试 F1 分数

转换并配置 blocking 函数后，运行：

```bash
python zeroer.py <dataset_name>
```

会输出：
- 数据集统计信息
- 特征范围信息
- 初始化统计信息
- EM 算法迭代过程
- **最终 F1、Precision、Recall 结果**

## 常见问题

### Q: 转换后找不到 blocking 函数？

A: 检查 `blocking_functions.py` 中是否有对应的函数，如果没有，需要添加。

### Q: Blocking 产生太多候选对？

A: 增加 `overlap_size` 参数，使用更严格的 blocking。

### Q: 特征提取太慢？

A: 使用 `--n_jobs 2` 或 `--n_jobs 4` 限制并行数。

### Q: F1 分数很低？

A: 检查：
1. 特征是否在 [0,1] 范围
2. 初始化正样本比例是否合理
3. Blocking 质量（正样本比例应该在 0.1%-10% 之间）

