# ZeroER 论文数据集与运行指南

## 论文信息
- **标题**: ZeroER: Entity Resolution using Zero Labeled Examples
- **会议**: SIGMOD 2020
- **ArXiv**: https://arxiv.org/abs/1908.06049
- **代码库**: 当前仓库

## 论文中使用的数据集

基于代码库中的 blocking 函数和注释，论文中可能使用了以下数据集：

### 1. Fodors-Zagats
- **类型**: 餐厅匹配（Restaurant Matching）
- **Blocking 函数**: `block_fodors_zagats`
- **运行命令**:
  ```bash
  python zeroer.py fodors_zagats
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py fodors_zagats --run_transitivity --LR_dup_free
  ```

### 2. DBLP-ACM
- **类型**: 学术论文匹配
- **Blocking 函数**: `block_dblp_acm`
- **候选对规模**: ~46K，漏掉 5 个正样本（共 2224 个）
- **运行命令**:
  ```bash
  python zeroer.py dblp_acm
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py dblp_acm --run_transitivity --LR_dup_free
  ```

### 3. DBLP-GoogleScholar
- **类型**: 学术论文匹配
- **Blocking 函数**: `block_dblp_scholar`
- **候选对规模**: ~135K，漏掉 467 个正样本（共 5347 个）
- **运行命令**:
  ```bash
  python zeroer.py dblp_scholar
  # 或使用别名
  python zeroer.py dblp_googlescholar
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py dblp_scholar --run_transitivity --LR_dup_free
  ```

### 4. Amazon-GoogleProducts
- **类型**: 产品匹配
- **Blocking 函数**: `block_amazon_googleproducts`
- **候选对规模**: ~400K，漏掉 6 个正样本（共 1300 个）
- **运行命令**:
  ```bash
  python zeroer.py amazon_googleproducts --n_jobs 4
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py amazon_googleproducts --run_transitivity --LR_dup_free --n_jobs 4
  ```

### 5. ABT-Buy
- **类型**: 产品匹配
- **Blocking 函数**: `block_abt_buy`
- **候选对规模**: ~164K，漏掉 6 个正样本（共 1097 个）
- **运行命令**:
  ```bash
  python zeroer.py abt_buy
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py abt_buy --run_transitivity --LR_dup_free
  ```

### 6. Walmart-Amazon
- **类型**: 产品匹配
- **Blocking 函数**: `block_walmart_amazon`
- **候选对规模**: ~278K，漏掉 84 个正样本（共 1154 个）
- **运行命令**:
  ```bash
  python zeroer.py walmart_amazon
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py walmart_amazon --run_transitivity --LR_dup_free
  ```

### 7. Beer
- **类型**: 啤酒产品匹配
- **Blocking 函数**: `block_beer`
- **正样本数**: 68 个（极不平衡数据集）
- **运行命令**:
  ```bash
  python zeroer.py beer --n_jobs 4
  ```
- **使用 Transitivity**:
  ```bash
  python zeroer.py beer --run_transitivity --LR_dup_free --n_jobs 4
  ```

## 关键参数说明

### 基本参数
- `--n_jobs`: 并行任务数（默认 4，使用 `-1` 使用所有核心）
  ```bash
  python zeroer.py <dataset> --n_jobs 4
  ```

### Transitivity 约束
- `--run_transitivity`: 启用传递性约束
- `--LR_dup_free`: 如果左右表都是无重复的，使用此参数可加速（不需要生成 LxL 和 RxR）
- `--LR_identical`: 单表去重任务（左右表相同）

**示例**:
```bash
# 如果表是 duplicate-free
python zeroer.py fodors_zagats --run_transitivity --LR_dup_free

# 如果表不是 duplicate-free（会生成 LxL 和 RxR，较慢）
python zeroer.py fodors_zagats --run_transitivity
```

## 超参数设置

代码中使用的默认超参数（在 `utils.py` 中）：
- `init_threshold = 0.8`: 初始化阈值（用于确定初始正样本）
- `c_bay = 0.015`: 协方差正则化参数（论文默认值）

这些参数在 `zeroer.py` 中硬编码：
```python
y_pred = run_zeroer(..., init_threshold=0.8, c_bay=0.015)
```

## 如何复现论文结果

### 步骤 1: 准备数据集
确保数据集已转换并放在 `datasets/` 目录下，包含：
- `tableA.csv` / `tableB.csv`: 左右表
- `matches.csv`: 真实匹配（用于评估）
- `metadata.txt`: 元数据文件

### 步骤 2: 检查 Blocking 函数
确保 `blocking_functions.py` 中有对应数据集的 blocking 函数，并在 `blocking_functions_mapping` 中注册。

### 步骤 3: 运行 ZeroER
```bash
# 基本运行（无 transitivity）
python zeroer.py <dataset_name> --n_jobs 4

# 使用 transitivity（如果适用）
python zeroer.py <dataset_name> --run_transitivity --LR_dup_free --n_jobs 4
```

### 步骤 4: 查看结果
- **终端输出**: F1、Precision、Recall
- **预测结果**: `datasets/<dataset_name>/pred.csv`

## 论文中可能的结果范围

根据实体解析领域的常见结果，ZeroER 在论文中可能报告的 F1 分数范围：

| 数据集 | 预期 F1 范围 | 说明 |
|--------|------------|------|
| Fodors-Zagats | 0.85-0.95 | 小数据集，匹配质量高 |
| DBLP-ACM | 0.90-0.98 | 学术数据，特征明显 |
| DBLP-GoogleScholar | 0.80-0.90 | 较大数据集，有噪声 |
| Amazon-GoogleProducts | 0.70-0.85 | 产品匹配，有变体 |
| ABT-Buy | 0.75-0.90 | 产品匹配 |
| Walmart-Amazon | 0.70-0.85 | 产品匹配，有噪声 |
| Beer | 0.20-0.50 | 极不平衡，正样本少 |

**注意**: 以上是估计范围，实际结果请参考论文或运行代码获取。

## 常见问题

### Q: 为什么我的 F1 分数很低？
A: 可能的原因：
1. 特征提取问题（特征未归一化）
2. 初始化阈值不合适（尝试调整 `init_threshold`）
3. Blocking 太严格或太宽松
4. 数据集本身不平衡（如 Beer）

### Q: 如何提高性能？
A: 
1. 使用 `--run_transitivity` 如果适用
2. 调整 `init_threshold`（在 `zeroer.py` 中修改）
3. 改进 blocking 函数
4. 检查特征质量

### Q: 运行很慢怎么办？
A:
1. 使用 `--n_jobs` 限制并行数（避免占用所有 CPU）
2. 如果不需要 transitivity，不要使用 `--run_transitivity`
3. 如果表是 duplicate-free，使用 `--LR_dup_free` 加速

## 参考

- 论文: https://arxiv.org/abs/1908.06049
- Magellan 文档: https://sites.google.com/site/anhaidgroup/projects/magellan/py_entitymatching

