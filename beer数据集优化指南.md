# Beer 数据集优化指南

基于 ZeroER 论文（SIGMOD 2020）的分析，针对 beer 数据集的极度不平衡特性（68 个正样本 vs 46万+ 候选对），提供以下优化策略。

## 数据集特点

- **正样本数**: 68 个（极不平衡）
- **候选对数**: ~46万+
- **正样本比例**: < 0.015%
- **Blocking**: `overlap_size=2`（已较严格）

## 论文中的关键发现

### 1. 正则化参数 κ' (c_bay)

**论文原文**（Section 5.4）:
> "We vary the regularization parameter κ' to understand how it affects the results... from 0 to 10% of the maximum BC value, i.e. [0,0.1], is a reasonable region for κ'... κ' = 0.01 is a good and safe default choice that works well for all datasets."

**关键发现**:
- 论文默认值: **κ' = 0.01** (1%)
- 代码默认值: **c_bay = 0.015** (1.5%)
- 有效范围: **[0, 0.1]**
- 性能曲线: F1 先增加（正则化有帮助），然后稳定，最后逐渐下降（过度正则化）

**针对 beer 的优化建议**:
- 尝试更小的值: `--c_bay 0.01`（论文默认）
- 如果 Precision 太低，尝试: `--c_bay 0.005`（更弱正则化）
- 如果 Recall 太低，尝试: `--c_bay 0.02`（更强正则化）

### 2. 初始化阈值 ε (init_threshold)

**论文原文**（Section 5.4）:
> "As shown in Figure 8(b), ZeroER is robust to initialization threshold ε with no changes on quality for all datasets. When ε = 0 or 1, no data is assigned to M or U class so that EM fails to recognize two clusters."

**关键发现**:
- 论文默认值: **ε = 0.5**
- 代码默认值: **init_threshold = 0.8**
- 论文说对 ε 不敏感，但 beer 数据集极度不平衡，可能需要调整

**针对 beer 的优化建议**:
- 尝试论文默认值: `--init_threshold 0.5`（初始化更多正样本）
- 如果初始化正样本太少，尝试: `--init_threshold 0.3`（更宽松）
- 如果初始化正样本太多（噪声多），尝试: `--init_threshold 0.9`（更严格）

### 3. 传递性约束 (Transitivity)

**论文原文**（Section 4）:
> "Incorporating transitivity in the model learning process, which gives a significant boost in model performance."

**关键发现**:
- 传递性约束可以显著提升性能
- 如果表是 duplicate-free，使用 `--LR_dup_free` 可加速

**针对 beer 的优化建议**:
- 如果 beer 表是 duplicate-free:
  ```bash
  python zeroer.py beer --run_transitivity --LR_dup_free --n_jobs 4
  ```
- 如果 beer 表不是 duplicate-free（会生成 LxL 和 RxR，较慢但更准确）:
  ```bash
  python zeroer.py beer --run_transitivity --n_jobs 4
  ```

### 4. Blocking 策略

**论文原文**（Section 5.4）:
> "We vary the aggressiveness of blocking by changing the overlapping size... A more aggressive blocking setting will generate less tuple pairs, but potentially at the risk of missing matches."

**关键发现**:
- 更严格的 blocking（更大的 `overlap_size`）会减少候选对，但可能漏掉正样本
- 当前 `block_beer` 使用 `overlap_size=2`，已经比较严格

**注意**: Blocking 函数在代码中，不能通过命令行调整。如果需要调整，需要修改 `blocking_functions.py` 中的 `block_beer` 函数。

### 5. 特征数量

**论文原文**（Section 5.4）:
> "We vary the amount (%) of features by sampling from the features generated by Magellan... The performance of ZeroER is robust to different (%) of features on most datasets except AG."

**关键发现**:
- ZeroER 对特征数量不敏感（除了 AG 数据集）
- 但 beer 数据集极度不平衡，可能需要更多高质量特征

## 推荐的优化策略（按优先级）

### 策略 1: 使用论文默认参数 + 传递性约束

```bash
# 使用论文默认的 c_bay=0.01 和 init_threshold=0.5
python zeroer.py beer --init_threshold 0.5 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
```

### 策略 2: 调整正则化参数（如果策略 1 效果不佳）

```bash
# 如果 Precision 太低（太多假阳性），降低 c_bay
python zeroer.py beer --init_threshold 0.5 --c_bay 0.005 --run_transitivity --LR_dup_free --n_jobs 4

# 如果 Recall 太低（漏掉太多正样本），提高 c_bay
python zeroer.py beer --init_threshold 0.5 --c_bay 0.02 --run_transitivity --LR_dup_free --n_jobs 4
```

### 策略 3: 调整初始化阈值（如果初始化质量差）

```bash
# 如果初始化正样本太少，降低阈值
python zeroer.py beer --init_threshold 0.3 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4

# 如果初始化正样本太多（噪声多），提高阈值
python zeroer.py beer --init_threshold 0.9 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
```

### 策略 4: 组合优化

```bash
# 尝试不同的组合
python zeroer.py beer --init_threshold 0.5 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
python zeroer.py beer --init_threshold 0.6 --c_bay 0.015 --run_transitivity --LR_dup_free --n_jobs 4
python zeroer.py beer --init_threshold 0.4 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
```

## 参数调优建议

### 诊断步骤

1. **查看初始化统计**:
   - 运行时会打印: `Initialization: X positive (Y%), Z negative (W%)`
   - 如果正样本比例 < 0.01%，考虑降低 `--init_threshold`
   - 如果正样本比例 > 1%，考虑提高 `--init_threshold`

2. **查看最终结果**:
   - 如果 Precision 很低（< 0.1），说明假阳性太多，考虑:
     - 提高 `--init_threshold`（更严格初始化）
     - 提高 `--c_bay`（更强正则化）
   - 如果 Recall 很低（< 0.5），说明漏掉太多正样本，考虑:
     - 降低 `--init_threshold`（更宽松初始化）
     - 降低 `--c_bay`（更弱正则化）

3. **使用传递性约束**:
   - 如果表是 duplicate-free，**强烈建议**使用 `--run_transitivity --LR_dup_free`
   - 这通常能提升 Precision，减少假阳性

## 预期效果

根据论文，beer 数据集是极度不平衡的数据集，即使优化后，F1 分数可能仍然较低（论文中未明确报告 beer 的结果）。但通过上述优化，应该能够：

- **提升 Precision**: 减少假阳性
- **提升 Recall**: 减少漏检
- **提升 F1**: 整体性能提升

## 注意事项

1. **不要过度优化**: 论文说参数在合理范围内性能稳定，不要过度调参
2. **优先使用传递性约束**: 这是论文中明确提到能显著提升性能的方法
3. **理解 trade-off**: Precision 和 Recall 之间存在 trade-off，需要根据应用场景选择
4. **数据质量**: 确保数据预处理正确，特征提取无误

## 参考命令

```bash
# 基础运行（默认参数）
python zeroer.py beer --n_jobs 4

# 论文默认参数 + 传递性约束（推荐）
python zeroer.py beer --init_threshold 0.5 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4

# 如果表不是 duplicate-free
python zeroer.py beer --init_threshold 0.5 --c_bay 0.01 --run_transitivity --n_jobs 4
```

## 针对当前结果的优化建议

### 当前问题分析

根据你的运行结果：
- **初始化正样本**: 18.55% (85596/461335) - **太多！**（实际只有 0.01%）
- **Precision**: 0.03 - **极低！**（假阳性太多）
- **Recall**: 0.79 - **较高**（找到大部分正样本）
- **F1**: 0.06 - **很低**（因为 Precision 太低）

### 优化策略

**核心问题**：初始化正样本太多，导致 EM 算法从错误的起点开始，产生大量假阳性。

**解决方案**：

1. **提高 init_threshold**（减少初始正样本）：
   ```bash
   # 测试 1: 使用代码默认值
   python zeroer.py beer --init_threshold 0.8 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
   
   # 测试 2: 更严格
   python zeroer.py beer --init_threshold 0.9 --c_bay 0.01 --run_transitivity --LR_dup_free --n_jobs 4
   ```

2. **提高 c_bay**（更强正则化，减少假阳性）：
   ```bash
   # 测试 3: 更强正则化
   python zeroer.py beer --init_threshold 0.8 --c_bay 0.02 --run_transitivity --LR_dup_free --n_jobs 4
   
   # 测试 4: 最严格组合
   python zeroer.py beer --init_threshold 0.9 --c_bay 0.02 --run_transitivity --LR_dup_free --n_jobs 4
   ```

3. **使用优化脚本**（系统测试）：
   ```bash
   bash optimize_beer.sh
   ```

### 预期改进

- **初始化正样本比例**: 从 18.55% 降到 < 5%（理想 < 1%）
- **Precision**: 从 0.03 提升到 > 0.1（理想 > 0.2）
- **F1**: 从 0.06 提升到 > 0.15（理想 > 0.3）

### 诊断标准

运行后检查：
1. **初始化统计**：`Initialization: X positive (Y%)`
   - 如果 Y > 5%，继续提高 `--init_threshold`
   - 理想值：Y < 1%（对于极度不平衡数据集）

2. **最终结果**：
   - 如果 Precision < 0.1，继续提高 `--init_threshold` 和 `--c_bay`
   - 如果 Recall < 0.5，降低 `--init_threshold`（但保持 < 0.8）
   - 目标是平衡 Precision 和 Recall，最大化 F1

